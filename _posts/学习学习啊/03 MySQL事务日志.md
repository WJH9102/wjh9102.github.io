# Mysql 事务日志

MySQL 中的事务有四大特性，分别是 ACID，对应原子性、一致性、隔离性和持久性。

- 事务的隔离性由锁机制来保证。
- 而一致性、原子性和隔离性由redo日志和unod 日志来保证
  - redo日志称为重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性，一定程度上也保证了一致性。
  - undo日志称为回滚日志，回滚记录到某个特定的版本，用来保证事务的原子性和一致性。

undo 日志和redo日志都可以视为一种恢复操作

- redo日志用来恢复因系统崩溃提交事务未落盘的数据，redo日志记录的是`物理级别`上对页的修改。
- undo日志用来恢复事务rollback 后的数据，记录的是`逻辑操作`日志是已执行操作的逆过程。

# 1.redo日志

Innodb 是以页为单位来访问和修改数据，在真正访问数据之前需要先将数据页加载到内存中的`buffer pool`中才能访问。之后所有的操作都必须先更新缓冲池中的数据，让后缓冲池中的`脏页`会以一定的频率刷入到磁盘中（checkPoint机制），通过缓冲池来优化磁盘和CPU 之间的鸿沟，这样才不会导致性能下降的很快。

## 1.1为什么要引入redo日志

缓冲池可以帮我们消除CPU和磁盘之间的鸿沟，checkPoint机制可以保证数据最终的落盘。然而由于checkPoint并不是每次都会触发，而是Innodb的master 线程定时处理。所以最坏的情况就是事务提交到缓冲池中了，但是服务器宕机导致缓冲池中的数据没有落盘。那么这段数据就是丢失的数据，无法恢复。

而事务的持久性要求我们，在事务提交后，即使系统崩溃，事务所做的修改都不能丢失。

那么如何保证持久性：

- 简单粗暴的方式：在事务提交完成之前将该事务所修改的页刷新到磁盘中，但是这样做的效率很低，主要体现在以下两个方面：
  - Innodb 访问和修改数据是以页为单位，但是如果事务修改的数据只有一个字节，也要刷新一个页16K的数据，显然付出与回报不成正比。
  - 如果修改的数据散落在多个数据页，而数据页之间并不是物理上连续的，那么就需要随机IO，而随机IO的效率非常低。
- 另一种高效的方式：由于我们的诉求是崩溃恢复，那么就可以将事务所作的每个操作都顺序记录下来，而不是每次提交时都刷新到磁盘。例如某个事务将第10 号页中偏移量为100的字节由1改为2。那么我么就只需要记录这些数据即可。

第二种方式就是Innodb引擎采用的WAL(Write Ahead Log)日志先行技术。只有日志写入成功，才算事务提交成功，这里的日志就是redo日志。当数据库宕机重启后，未及时刷新到磁盘的数据就可以通过redo日志进行恢复。

![img](https://secure2.wostatic.cn/static/ns4bDb7Sd3j1oTFbFAoexM/image.png?auth_key=1667630905-esLnkZZvpcaTsZgpRVkxTT-0-3d0597ed3613883dc66e24bed0be2921)







