# 长度最小的子数组

## 1.题目描述

给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。

**示例: **

> 输入: s = 7, nums = [2,3,1,2,4,3]
>
> 输出: 2

> 解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。

## 2.解题思路I（暴力法）

双重循环，固定一个下标 `i` （从0开始），从当前下标开始计算连续的子数组的和与所给值进行比较，如果符合要求则比较当前子数组的长度和上一次符合要求时的子数组的长度，记下较小值； `i++` 重复当前操作。

### 2.1Java代码

```java
private static int minSubArrayLen(int s, int[] nums) {
    int res = nums.length + 1;
    for (int i = 0; i < nums.length; i++) {
        int sum = 0;
        int j = i;
        while (j < nums.length && sum < s) {
            sum += nums[j];
            j++;
        }
        if (sum >= s) res = Math.min(res , j - i);
    }

    return res == nums.length + 1 ? 0 : res;
}
```

## 3.解题思路II（双指针，滑动窗口法）

维护两个指针， `left` 和 `right` 都从0开始，分别作为窗口的左右边界，维护变量`sum` 记录窗口内元素和

- 当`sum < s`时，`sum += nums[right];right++;`
- 当`sum >= s`时，`sum -= nums[left];left--;` 并记下窗口大小

### 3.1Java代码

```java
private static int minSubArrayLen(int s, int[] nums) {
    int res = nums.length + 1;

    int left = 0;
    int right = 0;
    int sum = 0;

    while (left < nums.length && right < nums.length) {
        while (sum < s && right < nums.length) {
            sum += nums[right];
            right++;
        }
        while (sum >= s) {
            res = Math.min(res, right - left);
            sum -= nums[left];
            left++;
        }
    }

    return res == nums.length + 1 ? 0 : res;
}
```
