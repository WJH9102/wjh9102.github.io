# 最佳观光组合

## 1.题目描述

> 给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。
>
> 一对景点（i < j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。

> 返回一对观光景点能取得的最高分。

> 示例：

> 输入：[8,1,5,2,6]

> 输出：11

> 解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11

>

> 提示：

> 1. 2 <= A.length <= 50000
> 2. 1 <= A[i] <= 1000

## 2.解决思路

**思路一：**  暴力破解，双重`for`循环，时间复杂对O(n<sup>2</sup>)，超时，不符合要求。

**思路二：**  对于`A[i] + A[j] + i - j`可以变形为`(A[i] + i) + (A[j] - j)`，对于每个 `j` ` A[j] - j`的值都是固定的，此时只需要找到在`0到j`之间找到`A[i] + i`的最大值即可。对于数组只需要遍历一次，时间复杂对为O(n).

### 2.1Java代码

```java
public int maxScoreSightseeingPair(int[] A) {
    int res = Integer.MIN_VALUE;
    // A[i] + i
    int left = A[0] + 0;
    // 对于固定的j A[j] - j 的值是固定的，此时只需要求0到j - 1中A[i] + i的最大值
    for (int j = 1; j < A.length; j++) {
        // 更新最大值
        res = Math.max(res, left + A[j] - j);
        // 更新0到j - 1中left的最大值
        left = Math.max(left, A[j] + j);
    }
    return res;
}
```
