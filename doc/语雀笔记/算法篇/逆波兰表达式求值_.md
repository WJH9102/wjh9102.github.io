# 逆波兰表达式求值_

> 根据逆波兰表示法，求表达式的值。
>
> 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
>
> 说明：
>
> 整数除法只保留整数部分。
> 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。
>
> 示例 1：
>
> 输入: ["2", "1", "+", "3", "*"]
> 输出: 9
> 解释: ((2 + 1) * 3) = 9
>
> 示例 2：
>
> 输入: [“4”, “13”, “5”, “/“, “+”]
> 输出: 6
> 解释: (4 + (13 / 5)) = 6
>
> 示例 3：
>
> 输入: ["10", "6", "9", "3", "+", "-11", " *&quot;, &quot;/&quot;, &quot;* ", "17", "+", "5", "+"]
> 输出: 22
> 解释:
>
> ((10 _ (6 / ((9 + 3) _ -11))) + 17) + 5
>
> = ((10 _ (6 / (12 _ -11))) + 17) + 5
>
> = ((10 * (6 / -132)) + 17) + 5
>
> = ((10 * 0) + 17) + 5
>
> = (0 + 17) + 5
>
> = 17 + 5
>
> = 22

### 1.解题思路（栈）

> 对后缀表达式依次入栈：
>
> - 遇见数字直接入栈
> - 遇见运算符则取栈顶的两个元素执行相应的运算操作，注意操作数的顺序，第一个出栈的为右操作数，第二个出栈的为左操作数，将运算后的结果压栈
> - 重复上述步骤，直到栈中只有一个元素，弹出返回即可

#### 1.1Java代码

```java
public static int evalRPN(String[] tokens) {
    Stack<Integer> stack = new Stack<>();
    for (String token : tokens) {
        if ("+".equals(token)) {
            int right = stack.pop();
            int left = stack.pop();
            stack.push(left + right);
        } else if ("-".equals(token)) {
            int right = stack.pop();
            int left = stack.pop();
            stack.push(left - right);
        } else if ("*".equals(token)) {
            int right = stack.pop();
            int left = stack.pop();
            stack.push(left * right);
        } else if ("/".equals(token)) {
            int right = stack.pop();
            int left = stack.pop();
            stack.push(left / right);
        } else {
            stack.push(Integer.parseInt(token));
        }
    }
    return stack.peek();
}
```

#### 1.2示意图

![](assets/network-asset-20200608153100-20250108101024-y2npdjg.gif)

### 2.解决思路（数组）

> 对于逆波兰表达式，操作数总比操作符多1（相当于没有括号的四则运算），故可以申请长度为tokens.length - 1 长度的数组，维护index指向有效操作数的后一位
>
> 遇见数字则`res[index++] = token`
>
> 遇见加法操作符则`res[index - 2] += res[--index]`，相当于将数组末尾的两个数组取出做运算后将结果放回倒数第二个操作数的位置，index后移，其它类似

#### 2.1Java代码

```java
public int evalRPN(String[] tokens) {
    Integer[] res = new Integer[tokens.length / 2 + 1];
    int index = 0;
    for (String token : tokens) {
        switch (token) {
            case "+": {
                res[index - 2] += res[--index];
                break;
            }
            case "-" : {
                res[index - 2] -= res[--index];
                break;
            }
            case "*" : {
                res[index - 2] *= res[--index];
                break;
            }
            case "/" : {
                res[index - 2] /= res[--index];
                break;
            }
            default: {
                res[index++] = Integer.parseInt(token);
                break;
            }
        }
    }
    return res[0];
}
```
