# 字符串四则运算_

> 有字符串表示的一个四则运算表达式，要求计算出该表达式的正确数值。四则运算即：加减乘除"+-*/"，另外该表达式中的数字只能是1位（数值范围0~9），运算可以包含括号和空格。另若有不能整除的情况，按向下取整处理，eg: 8/3得出值为2。
>
> 举例：字符串"8+7*2-9/3"，计算出其值为19。

### 1. 中缀表达式转后缀表达式

1. 遍历表达式遇到数字直接输出
2. 遇到运算符：
   - 栈为空，或栈顶元素运算符为`(`则直接入栈
   - 栈不空，且栈顶运算符优先级`<`该运算符则入栈
   - 栈不空，且栈顶运算符优先级`>=`该运算符则栈顶元素循环出栈输出，直到满足①②条件
   - 运算符为`(`，直接入栈
   - 运算符为`)`，栈顶元素循环出栈输出，直到栈顶元素为`(`，删除栈顶元素即`(`
3. 遇到空格`continue`，继续下一次循环。
4. 最后将栈中运算符依次出栈输出

#### 1.1示例

规则很多，还是用实例比较容易说清楚整个过程。以上面的转换为例，输入为a + b _ c + (d _ e + f)*g，处理过程如下：

1）首先读到a，直接输出。

2）读到“+”，将其放入到栈中。

3）读到b，直接输出。

此时栈和输出的情况如下：

![](assets/network-asset-20200604102143-20250108100953-c4j4pvd.png)

4）读到“_”，因为栈顶元素"+"优先级比" _ " 低，所以将" * "直接压入栈中。

5）读到c，直接输出。

此时栈和输出情况如下：

![](assets/network-asset-20200604102157-20250108100953-02f16n2.png)

6）读到" + "，因为栈顶元素" _ "的优先级比它高，所以弹出" _ "并输出， 同理，栈中下一个元素" + "优先级与读到的操作符" + "一样，所以也要弹出并输出。然后再将读到的" + "压入栈中。

此时栈和输出情况如下：

![](assets/network-asset-20200604102201-20250108100953-14ggobo.png)

7）下一个读到的为"("，它优先级最高，所以直接放入到栈中。

8）读到d，将其直接输出。

此时栈和输出情况如下：

![](assets/network-asset-20200604102205-20250108100953-ip1ann5.png)

9）读到" _ "，由于只有遇到" ) "的时候左括号"("才会弹出，所以" _ "直接压入栈中。

10）读到e，直接输出。

此时栈和输出情况如下：

![](assets/network-asset-20200604102209-20250108100953-zsb5hth.png)

11）读到" + "，弹出" * "并输出，然后将"+"压入栈中。

12）读到f，直接输出。

此时栈和输出情况：

![](assets/network-asset-20200604102212-20250108100953-6te1n94.png)

13）接下来读到“）”，则直接将栈中元素弹出并输出直到遇到"("为止。这里右括号前只有一个操作符"+"被弹出并输出。

![](assets/network-asset-20200604102218-20250108100954-ebio4kj.png)

14）读到" * "，压入栈中。读到g，直接输出。

![](assets/network-asset-20200604102228-20250108100954-le8oz28.png)

15）此时输入数据已经读到末尾，栈中还有两个操作符“*”和" + "，直接弹出并输出。

![](assets/network-asset-20200604102242-20250108100954-y6708bo.png)

#### 1.2中缀表达式转后缀表达式的代码实现

```java
public LinkedList<Character> calculateStr(String s) {
    Stack<Character> stack = new Stack<>();
    LinkedList<Character> out = new LinkedList<>();
    for (int i = 0; i < s.length(); i++) {
        char c = s.charAt(i);
        if (c == ' ') {
            continue;
        } else if (c == '+' || c == '-') {
            if (stack.isEmpty() || stack.peek() == '(') {
                stack.push(c);
            } else {
                while (!stack.isEmpty() && (stack.peek() == '*' || stack.peek() == '/' || stack.peek() == '+' || stack.peek() == '-')) {
                    out.add(stack.pop());
                }
                stack.push(c);
            }
        } else if (c == '*' || c == '/') {
            if (stack.isEmpty() || stack.peek() == '(' || stack.peek() == '+' || stack.peek() == '-') {
                stack.push(c);
            } else {
                while (!stack.isEmpty() && (stack.peek() == '*' || stack.peek() == '/')) {
                    out.add(stack.pop());
                }
                stack.push(c);
            }
        } else if (c == '(') {
            stack.push(c);
        } else if (c == ')') {
            while (stack.peek() != '(') {
                out.add(stack.pop());
            }
            stack.pop();
        } else {
            out.add(c);
        }
    }
    while (!stack.isEmpty()) {
        out.add(stack.pop());
    }
    return out;
}
```

### 2.后缀表达式求值

对后缀表达式依次入栈：

- 遇见数字直接入栈
- 遇见运算符则取栈顶的两个元素执行相应的运算操作，注意操作数的顺序，第一个出栈的为右操作数，第二个出栈的为左操作数，将运算后的结果压栈
- 重复上述步骤，直到栈中只有一个元素，弹出返回即可

#### 2.1后缀表达式的计算代码

```java
private int calculate (LinkedList<Character> strLink) {
    Stack<Integer> res = new Stack<>();
    for (char c : strLink) {
        switch (c) {
            case '+': {
                int right = res.pop();
                int left = res.pop();
                int a = left + right;
                res.push(a);
                break;
            }
            case '-': {
                int right = res.pop();
                int left = res.pop();
                int a = left - right;
                res.push(a);
                break;
            }
            case '*': {
                int right = res.pop();
                int left = res.pop();
                int a = left * right;
                res.push(a);
                break;
            }
            case '/': {
                int right = res.pop();
                int left = res.pop();
                int a = left / right;
                res.push(a);
                break;
            }
            default: {
                int a = c - 48;
                res.push(a);
                break;
            }
        }
    }
    if (res.size() > 1) {
        int result = 0;
        int count = 0;
        while (!res.isEmpty()) {
            result += res.pop() * Math.pow(10, count);
            count++;
        }
        return result;
    }
    return res.peek();
}
```
