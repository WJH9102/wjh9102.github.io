# 前缀树

前缀树也叫字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。

下图是一棵Trie树，表示了关键字集合{“a”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”} 。从上图可以归纳出Trie树的基本性质。

![](assets/network-asset-1687772942392-941b3e5e-6dfe-4cf1-b891-9f2fe3c3c883-20250107175151-6jkcggi.png)

它有三个性质：

1. 根节点不包含字符，除根节点外每一个节点都只包含一个字符。
2. 从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串。
3. 每个节点的所有子节点包含的字符都不相同。

#### 1.构建一个前缀树：

```java
public class TrieCp {
    private static class Node {
        private boolean end;
        private final TreeMap<Character, Node> next;
        public Node(boolean end) {
            this.end = end;
            this.next = new TreeMap<>();
        }
        public Node() {
            this(false);
        }

    }

    private final Node root;

    public TrieCp() {
        this.root = new Node();
    }

    /**
     * 根据单词构建前缀树
     * @param words
     */
    public void add(String words) {
        Node n = root;
        for (int i = 0; i < words.length(); i++) {
            char c = words.charAt(i);
            if (n.next.get(c) == null) {
                n.next.put(c, new Node());
            }
            n = n.next.get(c);
        }
        n.end = true;
    }

}
```

#### 2.匹配一个长字符串中所有的关键词

```java
public List<String> find(String line) {
    List<String> res = new ArrayList<>();
    Node n;
    for (int i = 0; i < line.length(); i++) {
        n = root;
        for (int j = i; j < line.length(); j++) {
            n = n.next.get(line.charAt(j));
            if (n == null) {
                break;
            }
            if (n.end) {
                res.add(line.substring(i, j + 1));
            }
        }
    }
    return res;
}
```

#### 3.查询指定前缀的所有关键词

```java
public List<String> findWordsWithPrefix(String prefix) {
    List<String> res = new ArrayList<>();
    Node n = root;
    for (int i = 0; i < prefix.length(); i++) {
        if (n.next.get(prefix.charAt(i)) == null) {
            return res;
        }
        n = n.next.get(prefix.charAt(i));
    }

    dfs(n, prefix, res);
    return res;
}

/**
 * 深度优先
 * @param n
 * @param prefix
 * @param res
 */
private void dfs(Node n, String prefix, List<String> res) {
    if (n.end) {
        res.add(prefix);
    }
    for (Character c : n.next.keySet()) {
        dfs(n.next.get(c), prefix + c, res);
    }
}
```

#### 4.测试用例

```java
public static void main(String[] args) {
    TrieCp trieCp = new TrieCp();
    trieCp.add("word");
    trieCp.add("words");
    trieCp.add("hello");
    trieCp.add("hey");
    trieCp.add("he");
    trieCp.add("fdkk");
    System.out.println(trieCp.find("addesnfdwordsfdkkshejfdsheyjfds"));
    System.out.println(trieCp.findWordsWithPrefix("he"));、
    // [word, words, fdkk, he, he, hey]
	// [he, hello, hey]
}
```
