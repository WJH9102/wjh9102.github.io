# 从先序遍历还原二叉树

## 1.题目描述

> 我们从二叉树的根节点 root 开始进行深度优先搜索。
>
> 在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。

> 如果节点只有一个子节点，那么保证该子节点为左子节点。

> 给出遍历输出 S，还原树并返回其根节点 root。

**示例 1：**

![](assets/network-asset-1592983243737-5e240a76-87ae-4c50-8c30-21e35fcdbe05-20250107175143-pqklawu.png)

> 输入："1-2--3--4-5--6--7"
>
> 输出：[1,2,5,3,4,6,7]

**示例 2：**

![](assets/network-asset-1592983268681-debc68ad-1fb0-4ef9-bac7-936d41a2d111-20250107175143-mp79yvq.png)

> 输入："1-2--3---4-5--6---7"
>
> 输出：[1,2,5,3,null,6,null,4,null,7]

**示例 3：**

![](assets/network-asset-1592983291003-5e114208-c183-4bbd-9ce4-90d56023177f-20250107175143-i3mzq1o.png)

> 输入："1-401--349---90--88"
>
> 输出：[1,401,null,349,88,90]

**提示：**

- 原始树中的节点数介于 1 和 1000 之间。
- 每个节点的值介于 1 和 10 ^ 9 之间。

## 2. 解决思路

维护一个栈，用来保存还有子结点的结点（孙子结点等等也算），并且从栈底开始数，从0开始，第n个元素在树中的度为n。

遍历字符串，每次遍历时维护变量 `level` 和 `val` 分别表示当前结点的深度（根结点的深度为0），本次遍历第一个数字前的'-'的个数表示当前结点的度，判断栈的大小和当前结点的度是否相同，否则栈顶元素出栈，直到栈的大小和当前结点的度相同，此时的栈顶元素刚好为当前结点的父节点，判断当前节点是否有左节点，没有则将当前结点置为其左节点，否则为右结点，同时当前结点入栈。

字符串遍历完成之后，栈的大小和最终的树的高度一致，将栈中元素循环出栈，直到只剩栈底元素，最后返回栈底元素。

### 2.1Java代码

```java
public TreeNode recoverFromPreorder(String S) {
    // 用来存放还有子结点（孙子结点也算）的结点，并且结点所在的位置代表其等级
    Stack<TreeNode> stack = new Stack<>();
    for (int i = 0; i < S.length();) {
        // 当前节点的等级，根节点等级为0
        int level = 0;

        // 每个结点的值
        int val = 0;

        // 下一个数字之前的 '-' 数即为该结点的等级
        while (S.charAt(i) == '-') {
            level++;
            i++;
        }

        // 计算当前节点的值，考虑多位数
        while (i < S.length() && S.charAt(i) != '-') {
            val += (S.charAt(i) - '0') + val * 10;
            i++;
        }

        // 构造当前结点
        TreeNode node = new TreeNode(val);

        /**
             * 当前结点入栈的隐藏条件是：从栈底数，从0开始，第level个位置就是当前节点的位置
             * 所以当stack.size() == level时入栈，此时的栈顶元素的等级为level - 1，刚好为当前结点
             * 的父节点
             */
        while (stack.size() > level) {
            stack.pop();
        }

        if (!stack.isEmpty()) {
            // 如果某结点只有一个孩子节点，则保证该子结点为左子结点（题目已知）
            if (stack.peek().left == null) {
                stack.peek().left = node;
            } else {
                stack.peek().right = node;
            }
        }
        stack.add(node);
    }
    // 构造完成之后栈中元素个数一定和树的高度一致
    System.out.println(stack.size());
    while (stack.size() > 1) {
        stack.pop();
    }
    return stack.pop();
}
```
