# 二叉树的前序遍历_

> 给定一个二叉树，返回它的 前序 遍历。
>
> 示例:
>
> 输入: [1,null,2,3]
> 1

2
/
3

> 输出: [1,2,3]
> 进阶: 递归算法很简单，你可以通过迭代算法完成吗？

### 1.解决思路

对于二叉树的前、中、后序遍历是指根节点的前中后，左节点永远在右节点左边，即

- 前序遍历：根左右
- 中序遍历：左中右
- 后序遍历：左右中

#### 1.1递归遍历

1. 输出根节点
2. 递归遍历左子树
3. 递归遍历右子树

##### 1.1.1Java代码

```java
public static List<Integer> recursive(TreeNode<Integer> root, List<Integer> res) {
    if (root != null) {
        res.add(root.val);
        recursive(root.left, res);
        recursive(root.right, res);
    }
    return res;
}
```

#### 1.2迭代遍历

> 维护一个栈，先将根节点压栈，遍历栈=>栈不为空=>取出栈顶元素=>输出栈顶值，同时如果该节点右节点不为空则入栈，如果该节点左节点不为空则入栈=>遍历栈

##### 1.2.1Java代码

```java
public static List<Integer> solution(TreeNode<Integer> root) {
    LinkedList<TreeNode<Integer>> stack = new LinkedList<>();
    List<Integer> res = new ArrayList<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode<Integer> head = stack.pop();
        res.add(head.val);
        if (head.right != null) {
            stack.push(head.right);
        }
        if (head.left != null) {
            stack.push(head.left);
        }
    }
    return res;
}
```

##### 1.2.2示意图

![](assets/network-asset-20200609222613-20250108100922-jbz08iy.gif)
