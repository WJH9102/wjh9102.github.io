# 最长公共前缀

> 编写一个函数来查找字符串数组中的最长公共前缀。
>
> 如果不存在公共前缀，返回空字符串 ""。

> 示例 1:

> 输入: ["flower","flow","flight"]

> 输出: "fl"

> 示例 2:

> 输入: ["dog","racecar","car"]

> 输出: ""

> 解释: 输入不存在公共前缀。

> 说明:

> 所有输入只包含小写字母 a-z 。

### 1.解决思路I

> 最长公共子前缀一定是数组中任意一个元素的子集（非真子集），所以可以以第一个元素为参考保存为ans，遍历剩下的元素；将剩下的元素中的每个字符都和第ans中的每个字符进行比较，如果有公共前缀则截取ans作为下一次比较的参考值，如果不存在公共子前缀则直接跳出循环，进行截取，截取后的ans为 `""` ，直接返回。

#### 1.1Java代码

```java
public static String longestCommonPrefix(String[] strs) {
    if (strs.length == 0) return "";
    String ans = strs[0];
    for (int i = 1; i < strs.length; i++) {
        int j = 0;
        while (j < Math.min(strs[i].length(), ans.length())) {
            if (strs[i].charAt(j) == ans.charAt(j)) {
                j++;
            } else {
                break;
            }
        }
        ans = ans.substring(0, j);
        if ("".equals(ans)) {
            return "";
        }
    }
    return ans;
}
```

### 2.解决思路II

> 同样是以第一个元素为参考，遍历剩下的元素，第二个元素进行`indexOf`操作，如果返回值不为0（前缀必须从第0个元素起），则对第一个元素的长度 `-1` ，直到 第一个元素是第二个元素的前缀，然后对后面的元素继续进行 `indexOf` 操作；或者第一个元素的长度为0，返回 `""` 。

#### 2.1Java代码

```java
public String longestCommonPrefix(String[] strs) {
    if(strs==null||strs.length==0) return "";
    for(int i=1;i<strs.length;i++){
        //单次求取每个元素的公共前缀，将第一个元素作为参照，循环将第一个元素长度从后缩短一个判断
        while(strs[i].indexOf(strs[0])!=0){
            strs[0]=strs[0].substring(0, strs[0].length()-1);
            if(strs[0].isEmpty()) return "";
        }     
    }
    return strs[0];
}
```
