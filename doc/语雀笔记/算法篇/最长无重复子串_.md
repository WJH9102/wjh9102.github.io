# 最长无重复子串_

> 给定一个字符串，找出不含有重复字符的最长子串的长度。
>
> 示例 1:
> 输入: "abcabcbb"
> 输出: 3
> 解释: 无重复字符的最长子串是 "abc"，其长度为 3。
>
> 示例 2:
> 输入: "bbbbb"
> 输出: 1.
> 解释: 无重复字符的最长子串是 "b"，其长度为 1。
>
> 示例 3:
> 输入: "pwwkew"
> 输出: 3
> 解释: 无重复字符的最长子串是 "wke"，其长度为 3。
> 请注意，答案必须是一个子串，"pwke" 是一个子序列 而不是子串。

### 1.解决思路

> 维护一个滑动窗口，窗口的左边界和右边界分别为l和r，初始时l和r都指向字符数组的第0个元素，然后r开始向右滑动，窗口不断扩大，并且窗口内都是不重复的字符
>
> 1. 如果r遍历到的字符从未出现过则r直接右移，并将划过的字符做上标记
> 2. 如果r遍历到的字符出现过则l又移（l右移之前记录窗口大小，取所有窗口大小中的最大值记为res），并擦除l遍历到的字符的标记
> 3. 重复1、2，直到l无法移动
> 4. res即为最长子串的长度

#### 1.1Java代码

```java
public static int mySolution(String s) {
    // 字符串转字符数组
    char[] chars = s.toCharArray();
    // 结果
    int res = 0;
    // 左右窗口
    int l = 0, r = 0;
    // 字符串标记，每个字符在数组中的位置固定，初始值为false
    boolean[] flag = new boolean[256];
    Arrays.fill(flag, false);
    // l从左滑到又
    while (l < chars.length) {
        // r从左滑到又
        while (r < chars.length && !flag[chars[r]]) {
            flag[chars[r]] = true;
            r++;
        }
        // 记录r滑不动时l的变化
        System.out.println(r + "," + l + "," + (r - l));
        // l又滑之前记录窗口大小
        res = Math.max(res, r - l);
        // 擦除l滑过的字符的标记
        flag[chars[l]] = false;
        // l又移
        l++;
    }
    return res;
}
```

#### 1.2示意图

![](assets/network-asset-20200525164245-20250108101006-abt5r0e.gif)
