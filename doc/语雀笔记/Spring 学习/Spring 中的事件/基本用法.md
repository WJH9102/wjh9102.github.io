# 基本用法

Spring 中的事件是基于观察者模式（发布-订阅模式）进行设计的，可以用来业务解耦，例如某项业务完成之后需要进行邮件发送、短信发送等等，并且后续还可能会新增其他的发送逻辑，此时就可以使用 Spring 中的事件机制。

发布订阅者模式类似于消息中间件，producer 将消息投递到制定 topic，然后 consumer 订阅指定 topic 即可进行消息消费。同样 Spring 事件中有也有类似的三大组件：

- 事件：ApplicationEvent，类似 topic 的功能，后续消费主要依赖监听器是否能够消费指定类型的 ApplicationEvent
- 事件监听器：ApplicationListener<T>、SmartApplicationListener，类似 consumer 的功能，用来消费指定事件，具体消费什么类型的事件下文会讲到
- 事件发布器：ApplicationEventMulticaster，类似 producer 的功能，这个默认由 Spring 提供，我们只做配置即可使用

## 定义事件

定义事件可以通过继承`ApplicationEvent`来实现：

```java
public class UserEvent extends ApplicationEvent {

    private String data;

    public UserEvent(Object source) {
        super(source);
    }

    public UserEvent(Object source, String data) {
        super(source);
        this.data = data;
    }

    public String getData() {
        return data;
    }

    public void setData(String data) {
        this.data = data;
    }

    @Override
    public String toString() {
        return "UserEvent{" +
                "data='" + data + '\'' +
                '}';
    }
}
```

## 定义监听器

定义监听器可以实现`ApplicationListener<T>`或者`SmartApplicationListener`，二者有所不同：

- 对于`ApplicationListener<T>`，具体消费的事件主要由泛型 T 来决定，即只要发布的事件是 T 类型，该监听器即可消费到该事件
- 对于`SmartApplicationListener`，消费的具体事件由`supportsEventType(Class<? extends ApplicationEvent> eventType)`和`supportsSourceType(Class<?> sourceType)`共同来决定，但是需要注意`supportsSourceType`是一个默认方法，默认返回 true

### 实现 ApplicationListener

```java
@Component
public class SaveUserEventListener implements ApplicationListener<UserEvent> {
    @Override
    public void onApplicationEvent(UserEvent event) {
        Object source = event.getSource();
        if (source instanceof Main01) {
            System.out.println("Save user: " + source);
        } else {
            System.out.println("Save user: " + event.getData());
        }
    }
}
```

### 实现 SmartApplicationListener

```java
@Component
public class PrintUserEventListener implements SmartApplicationListener {
    @Override
    public boolean supportsEventType(Class<? extends ApplicationEvent> eventType) {
        return eventType == UserEvent.class;
    }
    @Override
    public boolean supportsSourceType(Class<?> sourceType) {
        return sourceType == Main01.class;
    }
    @Override
    public void onApplicationEvent(ApplicationEvent event) {
        try {
            Thread.sleep(100);
            System.out.println(StrUtil.format("Thread: {}, event: {}", Thread.currentThread().getName(), event));
        } catch (InterruptedException e) {
        }
    }
}
```

## 发布事件

定义一个配置类：

```java
@Configuration
@ComponentScan("com.iflytek")
public class JavaConfig {
}

```

发布事件本质是 ApplicationEventMulticaster 提供的功能，在 Spring 中，ApplicationContext 代理了 ApplicationEventMulticaster 所以直接使用 ApplicationContext 也可以进行事件发布

```java
public class Main01 {
    public static void main(String[] args) {
        AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(JavaConfig.class);
        UserEvent test = new UserEvent(new Main01(), "test");
        ctx.publishEvent(test);
    }
}
```

## 拓展

### 通过注解定义监听器

通过实现接口的方式定义事件监听器有一定的局限性，即事件必须是 ApplicationEvent 类型，所以 Spring 提供了通过注解方式定义事件监听器的方式，这种方式定义的监听器消费的事件就不局限于 ApplicationEvent 了：

```java
@Component
public class MyBookListener {

    //注解中的泛型，就表示这个方法要处理的事件的类型，这里指定为 Book，即这个方法只处理 Book 类型的事件，对于其他类型的事件如 MyEvent 是不会处理的
    @EventListener(Book.class)
    public void handleBook(Book book) {
        System.out.println("MyBookListener : " + book);
    }

    @EventListener(Object.class)
    public void handle(Object o) {
        System.out.println("o = " + o);
    }
}
```

### 事件消费是阻塞还是非阻塞

要判断时间消费时阻塞还是非阻塞可以查看 ApplicationEventMulticaster 中具体事件消费的方法：

```java
@Override
public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {
	ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
	Executor executor = getTaskExecutor();
	for (ApplicationListener<?> listener : getApplicationListeners(event, type)) {
		if (executor != null) {
			executor.execute(() -> invokeListener(listener, event));
		}
		else {
			invokeListener(listener, event);
		}
	}
}
```

可以看到当 executor 不为 null 的时候就是异步消费，因此如果想要事件是异步消费，可以配置一个 ApplicationEventMulticaster bean，并给他设置现场池，以达到异步消费的目的：

```java
@Configuration
@ComponentScan("com.iflytek")
public class JavaConfig {

    @Bean
    ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor();
        taskExecutor.setCorePoolSize(Runtime.getRuntime().availableProcessors());
        taskExecutor.setMaxPoolSize(Runtime.getRuntime().availableProcessors() * 5);
        taskExecutor.setQueueCapacity(Runtime.getRuntime().availableProcessors() * 2);
        taskExecutor.initialize();
        return taskExecutor;
    }

    @Bean
    ApplicationEventMulticaster applicationEventMulticaster() {
        SimpleApplicationEventMulticaster multicaster = new SimpleApplicationEventMulticaster();
        multicaster.setTaskExecutor(taskExecutor());
        return multicaster;
    }
}
```
