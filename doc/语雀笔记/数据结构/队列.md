# 队列

## 1. 基本介绍

FIFO，先进先出

## 2. 自定义队列（数组模拟循环队列）

**基本约定：**

1. rear：指向队尾元素的下一个位置
2. front：指向队头元素的位置
3. queue：存放数据的数组
4. maxSize：队列的最大容量（存放数据的大小），实际数组大小为maxSize + 1

### 2.1队列为空

由于front指向队首元素，取出元素后front后移，而rear指向队尾元素的后一个位置，所以当取出最后一个元素后front和rear指向同一个位置，队列为空

即：当 `front == rear` 时队列为空

### 2.2队列满

**分两种情况：**

1. rear > front，此时只有当rear = maxSize - 1，front = 0时队列满
2. rear < front，此时满足rear + 1 = front

综合两种情况有当 `(rear + 1) % maxSize == front` 时队列满

### 2.3添加元素

添加元素之前需要判断队列是否满，如果满则不能添加。

rear指向队尾元素的后一个位置，当添加一个元素时，rear需要+1，但是当rear = maxSize - 1时，rear+1会导致数组越界异常，因此rear的新值应该是 `(rear + 1) % maxSize`。

### 2.4取出元素

取出元素前需要判断队列是否为空，如果为空则不能取出。

取出元素是在队头取出元素，即取出下标为front的元素，然后front+1，同样会出现数组越界的异常，所以采用取模的方式，front的新值为 `(front + 1) % maxSize`。

### 2.5队列中元素个数

**分两种情况：**

1. rear > front，此时队列中的元素有`rear- front`个
2. rear < front，此时队列中有 `maxSize + rear - front` 个元素

综合两种情况队列中有 ` (``maxSize + rear - front) % maxSize ` 个元素

## 3. Java实现队列代码

```java
class CircleQueue {
	private int front;
	private int rear;
	private int[] queue;
	private int maxSize;
	
	public CircleQueue() {
		front = 0;
		rear = 0;
		maxSize = 6;
		queue = new int[maxSize];
	}
	
	public CircleQueue(int maxSize) {
		this.maxSize = maxSize + 1;
		front = 0;
		rear = 0;
		queue = new int[this.maxSize];
	}
	
	
	public boolean isFull() {
		return (rear + 1) % maxSize == front; 
	}
	
	public boolean isEmpty() {
		return front == rear;
	}
	
	public void add(int val) {
		if (isFull()) {
			throw new RuntimeException("队列已满！");
		}
		queue[rear] = val;
		rear = (rear + 1) % maxSize;
	}
	
	public int pop() {
		if (isEmpty()) {
			throw new RuntimeException("队列为空！");
		}
		int val = queue[front];
		front = (front + 1) % maxSize;
		return val;
	}
	
	public int peek() {
		if (isEmpty()) {
			throw new RuntimeException("队列为空！");
		}
		return queue[front];
	}
	
	public int size() {
		return (maxSize + rear - front) % maxSize;
	}
	
	@Override
	public String toString() {
		StringBuilder sb = new StringBuilder();
		sb.append("[");
		for (int i = 0; i < size(); i++) {
			sb.append(queue[(i + front) % maxSize]).append(",");
		}
		String sub = sb.substring(0, sb.lastIndexOf(","));
		return sub + "]";
	}
	
}
```

## 4. 取模的公式

1. (a*b) mod M=(a mod M)* (b mod M) mod M;
2. (a+b) mod M=(a mod M+b mod M) mod M;
3. (a/b) mod M=(a*b^(M-2)) mod M;（费马小定理）
4. 如果 0 < a < M则，a mod M = (a + M) mod M，可以解释2.2和2.5
