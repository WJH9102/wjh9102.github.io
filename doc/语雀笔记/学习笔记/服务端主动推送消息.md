# 服务端主动推送消息

# 1.推送方式

后端向前端推送消息的方式主要有以下三种：

- web socket
- 前端轮询（伪推送）
- Server send event 简称 SSE

# 2.SSE简介

严格来讲 http 无法实现服务端主动推送消息，但是服务端可以向客户端声明接下来要发送流数据，即数据不是一次性发送完毕的，而是一个数据流，会连续不断的发送过来，此时客户端不会关闭连接，而是等待服务端发送数据，等到连接超时或者数据发送完毕服务端主动关闭连接才会断开。

# 3.spring MVC中使用

在一个 controller 中返回一个 `SseEmitter` 即可，构造方法可以定义超时时间，此后在超时时间内只需要拿着 `SseEmitter` 的实例调用 send 方法即可发送流数据。

```java
@GetMapping("subscribe")
public SseEmitter subscribe(HttpServletRequest request) {
    // 设置超时时间为5分钟
    SseEmitter sseEmitter = new SseEmitter(5 * 60 * 1000L);
    executor.execute(() -> {
        int i = 1;
        while (i <= 100) {
            try {
                sseEmitter.send(i);
                TimeUnit.MILLISECONDS.sleep(100);
            } catch (Exception e) {
                e.printStackTrace();
            }
            i++;
        }
        // 发送完毕后服务端主动端口连接
        sseEmitter.complete();
    });
    // 直接返回 SseEmitter 对象就可以和客户端连接
    return sseEmitter;
}
```

# 4.前端数据接收

sse 与传统的“请求-响应”模式不同，必须在前端使用一个 EventSource 来请求一个 sse ，并使用 onmessage 来处理响应数据。值得注意的是前端需要手动调用 close 方法来关闭这个 sse 请求，否则它会一直请求直到连接超时，而当服务端数据发送完毕后主动关闭连接前端会调用 onerror 回调，在此回调中 close 本次请求即可

```javascript
function subscribe(url) {
  if (!'EventSource' in window) {
    // 浏览器支持 SSE
    alert("浏览器不支持 SSE")
    return;
  }
  const source = new EventSource(url);

  // 连接一旦建立，就会触发 open 事件，可以在 onopen 属性定义回调函数
  source.onopen = function (event) {
    // ...
    console.log("连接已经建立")
    console.log(event)
  };

  // 客户端收到服务器发来的数据，就会触发 message 事件，可以在 onmessage 属性定义回调函数
  source.onmessage = function (event) {
    // data 就是服务器传回的数据（文本格式）
    const data = event.data;
    // handle message
  };

  // 如果发生通信错误（比如连接中断），就会触发 error 事件，可以在 onerror 属性定义回调函数
  source.onerror = function (event) {
    // handle error event
    console.log("error")
    source.close()
  };
}
```
