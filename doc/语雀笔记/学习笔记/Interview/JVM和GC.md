# JVM和GC

# 1.JVM的组成部分

![](assets/network-asset-1632131289817-9cb6d3a9-ed28-4a6f-a306-857d2ca8d5f2-20250107174334-erpx87a.png)

1. Class Loader 将 .class 文件加载到内存中
2. Execution Engine 执行引擎也叫解释器负责解释命令与操作系统交互
3. Native Interface 本地接口 在Native Method Stack 中注册本地方法（多为 C++ 编写的类库），Execution Engine 执行时加载 Native Libraies
4. Runtime Data Area 运行数据区是整个JVM的重点。我们所写的程序都被加载到这里才开始运行。

整个 JVM 框架由加载器加载文件，然后执行器在内存中处理数据，需要与异构系统交互可以通过本地接口进行。

# 2.类从编译到执行的过程

1. 编译器将 Java 源文件编译成 class 字节码文件
2. Class Loader 将字节码转换为 JVM 中的 Class<T> 对象
3. JVM 利用 Class<T> 对象实例化具体对象

# 3.谈谈Class Loader

ClassLoader 在 Java 中有着非常重要的作用，它主要工作在 Class 装载的加载阶段，其主要作用是从系统外部获得 Class 二进制数据流。它是 Java 的核心组件，所有的 Class 都是由 ClassLoader 进行加载的，ClassLoader 负责通过将 Class 文件里的二进制数据流装载进系统，然后交给 Java 虚拟机进行连接、初始化等操作。

## 3.1Class Loader的种类

1. BootStrapClassloader：C++ 编写，加载核心库 java.*
2. ExtClassLoader：Java 编写，加载扩展库 javax.*
3. AppClassLoader：Java 编写，加载程序所在目录（classPath下）
4. 自定义ClassLoader：Java 编写，定制化加载

## 3.2ClassLoader的双亲委派

1. 向上查找：当 new 一个对象时首先会检查对应的 class 文件是否被加载进内存，依次检查自定义ClassLoader、AppClassLoader、ExtClassLoader、BootstrapClassLoader
2. 向下加载：如果对应 class 文件没有被加载进内存，则依次委托对应 BootStrapClassLoader、ExtClassLoader、AppClassLoader、自定义 ClassLoader 进行加载

BootStrapClassLoader 会加载 `jre/lib` 下的类库，ExtClassLoader 会加载 `jre/lib/ext` 下的类库，AppClassLoader 会加载 CLASSPATH 下的类库

# 3.3类加载的两种方式

- `new` 关键字隐式加载
- `loadClass` 和 `forName` 显示加载

## 3.4loadClass和forName的区别

**类装载过程**

1. 加载：通过 ClassLader 加载 class 文件字节码，生成 Class 对象
2. 连接：
   1. 校验：检查加载的 class 的正确性和安全性
   2. 准备：为类变量分配存储空间并设置类变量初始值
   3. 解析：JVM 将常量池内的符号引用转换为直接引用
3. 初始化：执行类变量符合和静态代码块

**区别：**

- `ClassLoader.loadClass` 只执行了加载过程，spring IOC 的 lazy load 就使用了这种方式
- `Class.forName` 完成了初始化过程，例如加载 MySQL 的驱动类时就需要使用这种方式，因为 Driver 类中有静态代码块需要执行

# 4.Java内存模型

## 4.1线程独享

1. 程序计数器：记录当前线程执行字节码的行号，字节码解释器工作时通过修改程序计数器来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。
2. 虚拟机栈：由一个个栈帧组成，每个栈帧包含：局部变量表、操作数栈、动态链接、方法出口信息。局部变量表存放编译期可知的各种数据类型、对象引用。
   - 方法如何被调用：Java 栈中主要内容是栈帧，每一次方法调用都会有一个栈帧被压入栈，每一个函数调用结束后（return或抛出异常）都会导致栈帧被抛出
3. 本地方法栈：与虚拟机栈类似，但是 Java 虚拟机栈存放的是 Java 方法，本地方法栈存放的是 native 方法

## 4.2MateSpace和PremGen

`元空间`和`永久代`都是`方法区`的实现，实现方式不同，在 Java7 之后原先位于方法区的字符串常量池已经被移动到了 Java 堆中，并且在 Java8 中使用元空间替代了永久代。

**元空间相比永久代的优势：**

1. MateSpace 使用的是本地内存，PremGen 使用的是 JVM 内存
2. 字符串常量池存放在永久代中，容易出现性能问题和内存溢出
3. 类和方法的信息大小难以确定，给永久代的大小指定带来困难
4. 永久代会为 GC 带来不必要的复杂性

## 4.3Java堆

Java 堆是 JVM 中内存最大的一块，所有线程共享，可以是物理上不连续的内存空间。

## 4.4-Xms -Xmx -Xss的含义

- -Xss：规定了每个虚拟机栈的大小（256K足够）
- -Xms：规定了 Java 堆的初始大小
- -Xmx：规定了 Java 堆能达到的最大值（-Xms 和 -Xmx 一般设置成一样的，因为堆进行扩容时会发生内存抖动，影响程序稳定性）

## 4.5Java 内存模型中堆和栈的区别

1. 管理方式：栈自动释放，堆需要 GC
2. 空间大小：栈比堆小
3. 碎片相关：栈产生的碎片远小于堆
4. 分配方式：栈支持静态和动态分配，而堆仅支持动态分配
5. 效率：栈比堆高

## 4.6intern() 方法

**JDK6：** 当调用 intern 方法时，如果字符串常量池先前已经创建该字符串，则返回常量池中该字符串的引用，否则将此字符串添加到字符串常量池中，并返回该字符串对象的引用；

**JDK6+：** 当调用 intern 方法时，如果字符串常量池先前已经创建该字符串，则返回常量池中该字符串的引用，否则，如果该字符串对象已经存在于 Java 堆中，则将堆中此对象的引用添加到字符串常量池中，并返回该引用；如果堆中不存在，则在池中创建该字符串并返回其引用。

# 5.GC

## 5.1判断是否为垃圾的算法

1. 引用计数算法
2. 可达性分析算法

## 5.2可以作为GC Root的对象

1. 虚拟机栈中引用的对象（栈帧中的本地变量表）
2. 方法区中的常量引用的对象
3. 方法区中的类静态属性引用的对象
4. 本地方法栈中 JNI （Native 方法）的引用对象
5. 活跃线程引用的对象

## 5.3垃圾回收算法

1. 标记-清除算法

> 先标记后清除，容易产生大量不连续的碎片，效率比较差

2. 复制算法

> 为了解决效率问题，它将内存分为大小相同的两块，每次使用其中的一块。当这一块内存使用完后，就将还存活的对象复制到另一块，然后再把使用的空间一次清理掉。这样每次的内存回收都是对内存区间的一半进行回收。

1. 解决了碎片化的问题
2. 顺序分配内存，简单高效
3. 适用于对象存活率低的场景，例如年轻代
3. 标记-整理算法

> 标记过程和“标记-清除”算法一样，后续不是直接对可回收对象进行回收，而是让所有存活对象向一端移动，然后直接清理掉端边界以外的内存。

1. 避免了内存的不连续性
2. 不用设置两块内存互换
3. 适用于存活率高的场景，例如老年代
4. 分代收集算法

> 分代收集算法是一种整合算法，当前虚拟机都采用分代收集算法，这种算法根据对象存活周期不同将内存分为几块。一般将堆分为新生代和老年代，这样可以根据各个年代的特点选择合适的垃圾收集算法。例如在新生代采用“复制算法”，在老年代采用“标记-清除”或“标记-整理”算法

## 5.3GC的分类

1. Minor GC：发生在年轻代中的垃圾收集动作，所采用的垃圾回收算法为“复制算法”
2. Full GC：发生在老年代，对老年代的 GC 一般会伴随年轻代的 GC

![](assets/network-asset-1632206225090-d2d50854-29f5-4b71-b5eb-53eb54481d82-20250107174334-xzf253g.png)

## 5.4如何晋升到老年代

1. 经历一定 Minor 次数后任然存活的对象
2. Eden 和 Survivor 区中存放不下的对象
3. 新生的大对象

## 5.5常用的调优参数

1. -XX:SurvivorRatio：Eden 和 Survivor 的比值，默认8：1
2. -XX:NewRatio：老年代和年轻代内存大小比例，默认2：1
3. -XX:MaxTenuringThreshold：对象从年轻代晋升到老年代经过的 GC 次数，默认15

## 5.6出发Full GC的条件

1. 老年代空间不足
2. 永久代空间不足（JDK7 及以前）
3. CMS GC 时出现 promotion failed，concurrent mode failure
4. Minor GC 晋升到老年代的平均大小大于老年代的剩余空间
5. 调用 System.gc()，提醒进行并不一定
6. 使用RMI来进行RPC或管理的JDK应用，每小时执行一次 Full GC

## 5.7finalize()方法和C++的析构函数作用是否相同

1. 作用不同，析构函数调用确定，而 finalize 不是确定的
2. 将未被引用的对象放置在 F-Queue 队列，由优先级较低的线程执行
3. 方法执行随时可能会被终止
4. 给对象最后一次重生的机会
