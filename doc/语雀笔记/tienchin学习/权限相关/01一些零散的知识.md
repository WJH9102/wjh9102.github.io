# 01一些零散的知识

# 1.AntPathMatcher的使用

相关匹配规则：

- `?`：匹配一个字符

```java
public static void main(String[] args) {
    AntPathMatcher matcher = new AntPathMatcher();
    System.out.println(matcher.match("aaa?ccc", "aaaXccc")); // true
    // ? 只匹配一个字符
    System.out.println(matcher.match("aaa?ccc", "aaaXXccc")); // false
    // ? 只匹配一个字符
    System.out.println(matcher.match("aaa?ccc", "aaaccc")); // false
    // 目录 aaa?ccc 和 目录 aaa 不匹配
    System.out.println(matcher.match("aaa?ccc", "aaa/ccc")); // false
}
```

- `*`：匹配0个或多个字符

```java
public static void main(String[] args) {
    AntPathMatcher matcher = new AntPathMatcher();
    System.out.println(matcher.match("aaa*ccc", "aaaXccc")); // true
    System.out.println(matcher.match("aaa*ccc", "aaaXXccc")); // true
    System.out.println(matcher.match("aaa*ccc", "aaaccc")); // true
    // 目录 aaa*ccc 和 目录 aaa 不匹配
    System.out.println(matcher.match("aaa*ccc", "aaa/XXccc")); // false
    // 目录 aaa*ccc 和 目录 aaa 不匹配
    System.out.println(matcher.match("aaa*ccc", "aaa/ccc")); // false
}
```

- `**`：匹配0个或多个目录

```java
  public static void main(String[] args) {
    AntPathMatcher matcher = new AntPathMatcher();
    System.out.println(matcher.match("aaa/**", "aaa/")); // true
    System.out.println(matcher.match("aaa/**", "aaa")); // true
    // 目录 ccc 和 空目录不匹配
    System.out.println(matcher.match("aaa/**/ccc", "aaa/")); // false
    // 目录 ccc 和 空目录不匹配
    System.out.println(matcher.match("aaa/**/ccc", "aaa")); // false
    System.out.println(matcher.match("aaa/**/ccc", "aaa/XX/ccc")); // true
    // 目录 aaa 和 目录 aaaccc 不匹配
    System.out.println(matcher.match("aaa/**/ccc", "aaaccc")); // false
    System.out.println(matcher.match("aaa/**/ccc", "aaa/XX/YY/ccc")); // true
    System.out.println(matcher.match("aaa/**/ccc", "aaa/ccc")); // true
    System.out.println(matcher.match("aaa/**/ccc", "aaa//ccc")); // true
}
```

由上可知，当匹配规则中只有一个目录且不带`/`时可以当作字符串匹配规则来使用，例如上面的`?`和`*`的用法。

# 2.SPEL的使用

SPEL 为 spring 中的表达式语言，类似于 JSP 中的 EL 表达式。

#### 1.如何使用？

1. 解析简单表达式

```java
@Test
void spel01() {
    SpelExpressionParser parser = new SpelExpressionParser();
    String express = "1+1";
    SpelExpression spelExpression = parser.parseRaw(express);
    Integer result = spelExpression.getValue(Integer.class);
    System.out.println("result = " + result); // result = 2
}
```

2. 设置表达式上下文环境

```java
@Test
void spel02() {
    SpelExpressionParser parser = new SpelExpressionParser();
    // 获取 user 中的 name 属性
    String express = "#user.name";
    SpelExpression spelExpression = parser.parseRaw(express);
    StandardEvaluationContext ctx = new StandardEvaluationContext();
    User user = new User();
    user.setId("1001");
    user.setName("zhang san");
    user.setAddress("北京");
    // 设置上下文环境
    ctx.setVariable("user", user);
    String value = spelExpression.getValue(ctx, String.class);
    System.out.println("value = " + value); // value = zhang san
}
```

3. 设置根上下文环境，可以省略`#user`，同时还可以调用上下文环境中的方法

```java
@Test
void spel03() {
    SpelExpressionParser parser = new SpelExpressionParser();
    // 获取 user 中的 name 属性
    String express1 = "name";
    // 调用 user 中的 hello() 方法
    String express2 = "hello()";
    // 调用 user 中的 hello() 方法 并传参
    String express3 = "hello('world')";
    SpelExpression spelExpression1 = parser.parseRaw(express1);
    SpelExpression spelExpression2 = parser.parseRaw(express2);
    SpelExpression spelExpression3 = parser.parseRaw(express3);
    StandardEvaluationContext ctx = new StandardEvaluationContext();
    User user = new User();
    user.setId("1001");
    user.setName("zhang san");
    user.setAddress("北京");
    // 设置根上下文环境
    ctx.setRootObject(user);
    String value1 = spelExpression1.getValue(ctx, String.class);
    System.out.println("value1 = " + value1); // value1 = zhang san
    String value2 = spelExpression2.getValue(ctx, String.class);
    System.out.println("value2 = " + value2); // value2 = hello
    String value3 = spelExpression3.getValue(ctx, String.class);
    System.out.println("value3 = " + value3); // value3 = hello world
}
```

4. 解析关于 spring 容器中的 bean 的表达式

```java
@Test
void spel04() {
    SpelExpressionParser parser = new SpelExpressionParser();
    // beanName 为 us 的 hello() 方法
    String express = "@us.hello()";
    SpelExpression spelExpression = parser.parseRaw(express);
    StandardEvaluationContext ctx = new StandardEvaluationContext();
    // 设置 spring 上下文环境 beanFactory 通过自动注入而来
    ctx.setBeanResolver(new BeanFactoryResolver(beanFactory));
    String value = spelExpression.getValue(ctx, String.class);
    System.out.println("value = " + value); // value = hello UserService
}
```

#### 2.使用场景

1. spring security 中的 `@PreAutorize`注解中可以传入 SPEL 表达式，用来判断是否具有某个权限
2. 自定义注解中传入 SPEL 表达式结合 AOP 通过 SpelExpressionParser 来解析

#### 3.上述案例中的其他代码

1. User 实体

```java
public class User {
    private String id;
    private String name;
    private String address;

    public String hello() {
        return "hello";
    }

    public String hello(String str) {
        return "hello " + str;
    }
    // setter getter
}
```

2. UserService 对象

```java
@Service("us")
public class UserService {
    public String hello() {
        return "hello UserService";
    }
}
```
