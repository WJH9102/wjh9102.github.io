# 05动态代理

# 1.实现方式

众所周知动态代理总共由两种实现方式：

- JDK 动态代理
  - 需要被代理对象有接口，代理的方法为接口中的方法
  - 生成的代理对象为父接口的实现类并非被代理对象的子类
- CGLIB 动态代理
  - 对被代理对象没有要求，是否有接口都可代理
  - 生成的代理对象为被代理对象的子类，所以只能代理 public 方法

# 2.具体实现

不改变源代码的前提下计算方法执行事件。

## 2.1JDK 动态代理

**父接口：**

```java
public interface Calculator {
    void add(int a, int b);
}
```

**接口实现类：**

```java
public class CalculatorImpl implements Calculator {
    @Override
    public void add(int a, int b) {
        System.out.println(a + "+" + b + "=" + (a + b));
    }
}
```

**动态代理：**

```java
public class JdkProxy {
    public static void main(String[] args) {
        Calculator calculator = (Calculator) Proxy.newProxyInstance(JdkProxy.class.getClassLoader(), new Class[]{Calculator.class}, new InvocationHandler() {
            /**
             * 拦截方法
             *
             * @param proxy  被代理对象
             * @param method 被代理方法
             * @param args   方法参数
             * @return
             * @throws Throwable
             */
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                long s = System.nanoTime();
                Object res = method.invoke(new CalculatorImpl(), args);
                System.out.println(method.getName() + " 方法执行耗时 " + (System.nanoTime() - s) + "纳秒");
                return res;
            }
        });
        calculator.add(1 ,2);
        // 1+2=3
        //add 方法执行耗时 947100纳秒
    }
}
```

## 2.2CBLIB 动态代理

CGLIB 动态代理依赖三方 JAR 包：

```xml
<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
    <version>3.2.5</version>
</dependency>
```

**代理类：**

```java
public class Calculator {
    public void add(int a, int b) {
        System.out.println(a + "+" + b + "=" + (a + b));
    }
}
```

**拦截方法：**

```java
public class CalculatorInterceptor implements MethodInterceptor {
    /**
     * 拦截后的增强方法
     * @param o 拦截对象
     * @param method 拦截方法
     * @param objects 方法参数
     * @param methodProxy 方法对象
     * @return
     * @throws Throwable
     */
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        long s = System.nanoTime();
        Object res = methodProxy.invokeSuper(o, objects);
        System.out.println(method.getName() + " 方法执行耗时 " + (System.nanoTime() - s) + "纳秒");
        return res;
    }
}
```

**动态代理：**

```java
public class CglibProxy {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        // 设置父类
        enhancer.setSuperclass(Calculator.class);
        // 设置回调 即 拦截方法
        enhancer.setCallback(new CalculatorInterceptor());
        Calculator calculator = (Calculator) enhancer.create();
        calculator.add(1, 2);
    }
}
```
